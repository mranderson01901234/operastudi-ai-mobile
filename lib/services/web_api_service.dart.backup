import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';
import 'package:http/http.dart' as http;
import 'package:supabase_flutter/supabase_flutter.dart';

class WebAPIService {
  // Production API endpoints
  static const String baseUrl = 'http://localhost:8888';
  static const String replicatePredictEndpoint = '/.netlify/functions/replicate-predict';
  static const String replicateStatusEndpoint = '/.netlify/functions/replicate-status';
  static const String enhanceGeneralEndpoint = '/.netlify/functions/api-v1-enhance-general';
  
  // Note: These endpoints may not exist yet, but keeping them for future implementation
  static const String userCreditsEndpoint = '/.netlify/functions/api-v1-user-credits';
  static const String userHistoryEndpoint = '/.netlify/functions/api-v1-user-history';
  static const String apiKeysEndpoint = '/.netlify/functions/api-v1-api-keys-list';
  
  static final SupabaseClient _supabase = Supabase.instance.client;

  // Test API connectivity
  static Future<void> testAPIConnection() async {
    try {
      // Test with a minimal POST request to see if endpoint responds
      final response = await http.post(
        Uri.parse('$baseUrl$replicatePredictEndpoint'),
        headers: {'Content-Type': 'application/json'},
        body: json.encode({'test': 'connectivity'}),
      ).timeout(const Duration(seconds: 10));
      
      print('API Test - Status: ${response.statusCode}');
      print('API Test - Response: ${response.body}');
      
      if (response.statusCode == 400) {
        print('‚úÖ Endpoint exists and responds (400 = bad request, expected without proper data)');
      } else if (response.statusCode == 401) {
        print('‚úÖ Endpoint exists but requires authentication');
      } else if (response.statusCode == 200 || response.statusCode == 201) {
        print('‚úÖ Endpoint accessible');
      } else if (response.statusCode == 404) {
        print('‚ùå Endpoint not found - Check deployment');
      } else {
        print('‚ö†Ô∏è Endpoint returned: ${response.statusCode}');
      }
    } catch (e) {
      print('‚ùå Network error: $e');
    }
  }

  // Test authentication
  static Future<void> testAuthentication() async {
    try {
      final session = _supabase.auth.currentSession;
      if (session != null) {
        print('‚úÖ User authenticated: ${session.user.email}');
        print('‚úÖ Token expires: ${DateTime.fromMillisecondsSinceEpoch(session.expiresAt! * 1000)}');
        
        // Test authenticated request
        final response = await http.post(
          Uri.parse('$baseUrl$replicatePredictEndpoint'),
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ${session.accessToken}',
          },
          body: json.encode({'test': 'auth'}),
        ).timeout(const Duration(seconds: 10));
        
        print('‚úÖ Authenticated request status: ${response.statusCode}');
      } else {
        print('‚ùå No authentication session');
      }
    } catch (e) {
      print('‚ùå Auth test error: $e');
    }
  }

  // Get user credits (placeholder - endpoint may not exist yet)
  static Future<Map<String, dynamic>> getUserCredits() async {
    try {
      final session = _supabase.auth.currentSession;
      if (session == null) {
        throw Exception('User not authenticated');
      }

      final response = await http.get(
        Uri.parse('$baseUrl$userCreditsEndpoint'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ${session.accessToken}',
        },
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 200 || response.statusCode == 201) {
        return json.decode(response.body);
      } else {
        throw Exception('Failed to get credits: ${response.statusCode} - ${response.body}');
      }
    } catch (e) {
      print('Get credits error: $e');
      // Return mock data for development
      return {
        'credits_remaining': 10,
        'subscription_tier': 'free',
      };
    }
  }

  // Get user history (placeholder - endpoint may not exist yet)
  static Future<Map<String, dynamic>> getUserHistory() async {
    try {
      final session = _supabase.auth.currentSession;
      if (session == null) {
        throw Exception('User not authenticated');
      }

      final response = await http.get(
        Uri.parse('$baseUrl$userHistoryEndpoint'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ${session.accessToken}',
        },
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 200 || response.statusCode == 201) {
        return json.decode(response.body);
      } else {
        throw Exception('Failed to get history: ${response.statusCode} - ${response.body}');
      }
    } catch (e) {
      print('Get history error: $e');
      // Return mock data for development
      return {
        'history': [],
        'total_processed': 0,
      };
    }
  }

  // Enhance image using General Enhancement model - PRODUCTION MODE
  static Future<Map<String, dynamic>> enhanceGeneral(File imageFile) async {
    try {
      // Get authenticated session
      final session = _supabase.auth.currentSession;
      if (session == null) {
        throw Exception('User not authenticated');
      }

      // Convert image to base64 (required format for your API)
      final bytes = await imageFile.readAsBytes();
      final base64Image = base64Encode(bytes);
      final dataUrl = 'data:image/jpeg;base64,$base64Image';

      // Create request body matching your web platform format
      final requestBody = {
        'input': {
          'image': dataUrl,
          'scale': '2x',
          'sharpen': 37,
          'denoise': 25,
          'faceRecovery': false,
          'model_name': 'real image denoising'
        }
      };

      print('üöÄ PRODUCTION: Starting API call to: $baseUrl$replicatePredictEndpoint');
      print('üìä Request body size: ${json.encode(requestBody).length} bytes');

      // Make API call with JWT authentication
      final response = await http.post(
        Uri.parse('$baseUrl$replicatePredictEndpoint'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ${session.accessToken}',
        },
        body: json.encode(requestBody),
      ).timeout(const Duration(seconds: 30));

      print('üì° API Response Status: ${response.statusCode}');
      print('üì° API Response Body: ${response.body}');

      if (response.statusCode == 200 || response.statusCode == 201) {
        final responseData = json.decode(response.body);
        
        // Check if we got a proper Replicate response
        if (responseData.containsKey('id')) {
          print('‚úÖ Got Replicate prediction ID: ${responseData['id']}');
          return responseData;
        } else {
          print('‚ùå Unexpected response format from API');
          throw Exception('Invalid response format from API: ${response.body}');
        }
      } else {
        print('‚ùå API Error ${response.statusCode}: ${response.body}');
        throw Exception('API Error ${response.statusCode}: ${response.body}');
      }

    } catch (e) {
      print('‚ùå Enhancement failed: $e');
      throw Exception('Enhancement failed: ${e.toString()}');
    }
  }

  // Check processing status - PRODUCTION MODE
  static Future<Map<String, dynamic>> checkStatus(String predictionId) async {
    try {
      final session = _supabase.auth.currentSession;
      if (session == null) {
        throw Exception('User not authenticated');
      }

      print('üîç Checking status for prediction: $predictionId');

      // Call the real status endpoint
      final response = await http.get(
        Uri.parse('$baseUrl$replicateStatusEndpoint/$predictionId'),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ${session.accessToken}',
        },
      ).timeout(const Duration(seconds: 10));

      print('üîç Status check response: ${response.statusCode}');

      if (response.statusCode == 200 || response.statusCode == 201) {
        final responseData = json.decode(response.body);
        
        // Check if we got a proper Replicate status response
        if (responseData.containsKey('status')) {
          print('‚úÖ Got Replicate status: ${responseData['status']}');
          return responseData;
        } else {
          print('‚ùå Unexpected status response format');
          throw Exception('Invalid status response format: ${response.body}');
        }
      } else {
        print('‚ùå Status endpoint error ${response.statusCode}: ${response.body}');
        throw Exception('Status check failed: ${response.statusCode} - ${response.body}');
      }

    } catch (e) {
      print('‚ùå Status check error: $e');
      throw Exception('Status check failed: ${e.toString()}');
    }
  }

  // Poll for completion with progress tracking - PRODUCTION MODE
  static Future<Map<String, dynamic>> pollForResult(
    String predictionId, {
    Function(double progress, String status)? onProgress,
  }) async {
    print('‚è≥ Starting polling for prediction: $predictionId');
    
    // Poll the real status endpoint
    for (int attempt = 0; attempt < 60; attempt++) { // 5 minutes max
      try {
        // Update progress
        double progress = 0.3 + (attempt / 60.0) * 0.7; // 30% to 100%
        onProgress?.call(progress, 'Processing...');
        
        // Check status using real endpoint
        final statusResult = await checkStatus(predictionId);
        
        if (statusResult['status'] == 'succeeded') {
          onProgress?.call(1.0, 'Complete!');
          return statusResult;
        } else if (statusResult['status'] == 'failed') {
          throw Exception('Processing failed: ${statusResult['error']}');
        }
        
        // Wait 5 seconds before next check
        await Future.delayed(const Duration(seconds: 5));
      } catch (e) {
        print('Poll attempt $attempt failed: $e');
        if (attempt == 59) rethrow; // Last attempt, rethrow error
      }
    }
    
    throw Exception('Processing timed out');
  }

  // Download enhanced image
  static Future<Uint8List> downloadImage(String imageUrl) async {
    try {
      print('üì• Downloading image from: $imageUrl');
      
      final response = await http.get(Uri.parse(imageUrl))
          .timeout(const Duration(seconds: 30));

      if (response.statusCode == 200 || response.statusCode == 201) {
        print('‚úÖ Image downloaded successfully: ${response.bodyBytes.length} bytes');
        return response.bodyBytes;
      } else {
        throw Exception('Download failed with status: ${response.statusCode}');
      }
    } catch (e) {
      print('‚ùå Download error: $e');
      throw Exception('Failed to download enhanced image: $e');
    }
  }
}
