import 'dart:io';
import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import '../config/opera_studio_config.dart';
import '../services/web_api_service.dart';
import '../services/processing_history_service.dart';
import '../exceptions/custom_exceptions.dart';
import 'cloud_storage_service.dart';
import 'auth_service.dart';

// import 'package:gal/gal.dart';
class AppState extends ChangeNotifier {
  // Image state
  File? _selectedImage;
  File? _processedImage;
  
  // Processing states
  bool _isProcessing = false;
  bool _isAiEnhancing = false;
  double _processingProgress = 0.0;
  String _processingStatus = '';
  
  // User state
  int _userCredits = 0;
  Map<String, dynamic>? _userProfile;
  
  // Error state
  String? _error;

  // Image editing properties
  String? _selectedFilter;
  double _brightness = 0.0;
  double _contrast = 0.0;
  double _saturation = 0.0;
  double _warmth = 0.0;

  // Comparison functionality
  bool _isComparisonMode = false;
  double _comparisonSliderValue = 0.5;

  // Constructor - give test credits for development
  AppState() {
    _userCredits = 10; // Give 10 test credits for development
  }

  // Getters
  File? get selectedImage => _selectedImage;
  File? get processedImage => _processedImage;
  bool get isProcessing => _isProcessing;
  bool get isAiEnhancing => _isAiEnhancing;
  double get processingProgress => _processingProgress;
  String get processingStatus => _processingStatus;
  int get userCredits => _userCredits;
  Map<String, dynamic>? get userProfile => _userProfile;
  String? get error => _error;
  bool get isImageLoaded => _selectedImage != null;

  // Image editing getters
  String? get selectedFilter => _selectedFilter;
  double get brightness => _brightness;
  double get contrast => _contrast;
  double get saturation => _saturation;
  double get warmth => _warmth;

  // Comparison getters
  bool get canCompareImages => _selectedImage != null && _processedImage != null;
  bool get isComparisonMode => _isComparisonMode;
  double get comparisonSliderValue => _comparisonSliderValue;
  
  // Computed properties
  File? get displayImage => _processedImage ?? _selectedImage;
  bool get hasAnyAdjustments => _brightness != 0.0 || _contrast != 0.0 || _saturation != 0.0 || _warmth != 0.0 || _selectedFilter != null;
  String? get errorMessage => _error;

  // Image management
  void setSelectedImage(File image) {
    _selectedImage = image;
    _processedImage = null;
    _error = null;
    notifyListeners();
  }

  void resetImage() {
    _selectedImage = null;
    _processedImage = null;
    _error = null;
    notifyListeners();
  }

  void setProcessing(bool processing) {
    _isProcessing = processing;
    notifyListeners();
  }

  void setError(String? error) {
    _error = error;
    notifyListeners();
  }

  void clearError() {
    _error = null;
    notifyListeners();
  }

  void updateUserCredits(int credits) {
    _userCredits = credits;
    notifyListeners();
  }

  // Add test credits for development
  void addTestCredits(int credits) {
    _userCredits += credits;
    notifyListeners();
  }

  // Image editing methods
  void setSelectedFilter(String? filter) {
    _selectedFilter = filter;
    notifyListeners();
  }

  void setBrightness(double brightness) {
    _brightness = brightness;
    notifyListeners();
  }

  void setContrast(double contrast) {
    _contrast = contrast;
    notifyListeners();
  }

  void setSaturation(double saturation) {
    _saturation = saturation;
    notifyListeners();
  }

  void setWarmth(double warmth) {
    _warmth = warmth;
    notifyListeners();
  }

  // Comparison methods
  void toggleComparisonMode() {
    _isComparisonMode = !_isComparisonMode;
    notifyListeners();
  }
  
  void updateComparisonSlider(double value) {
    _comparisonSliderValue = value;
    notifyListeners();
  }

  // Enhanced AI processing workflow
  Future<void> enhanceImageWithAi() async {
    if (_selectedImage == null) {
      setError('No image selected for AI enhancement');
      return;
    }

    try {
      _isAiEnhancing = true;
      _processingProgress = 0.0;
      _processingStatus = 'Preparing image...';
      notifyListeners();

      // Step 1: Validate image and check credits
      await _validateImageAndCredits();
      _processingProgress = 0.1;
      _processingStatus = 'Checking credits...';
      notifyListeners();

      // Step 2: Upload image and create prediction
      _processingProgress = 0.2;
      _processingStatus = 'Uploading image...';
      notifyListeners();
      
      final predictionResult = await WebAPIService.enhanceGeneral(_selectedImage!);
      final predictionId = predictionResult['id'];

      // Step 3: Poll for completion with progress updates
      _processingProgress = 0.3;
      _processingStatus = 'Processing with AI...';
      notifyListeners();

      final completedResult = await _pollForResultWithProgress(predictionId);

      // Step 4: Download and save result
      _processingProgress = 0.8;
      _processingStatus = 'Downloading result...';
      notifyListeners();

      await _processEnhancedResult(completedResult);

      // Step 5: Update credits and history
      _processingProgress = 0.95;
      _processingStatus = 'Updating account...';
      notifyListeners();

      await _updateUserCreditsAndHistory();

      _processingProgress = 1.0;
      _processingStatus = 'Complete!';
      
      // Clear status after 2 seconds
      Future.delayed(const Duration(seconds: 2), () {
        _processingStatus = '';
        notifyListeners();
      });

    } catch (e) {
      setError(_handleProcessingError(e));
    } finally {
      _isAiEnhancing = false;
      _processingProgress = 0.0;
      notifyListeners();
    }
  }

  Future<void> _validateImageAndCredits() async {
    // Validate file size
    final fileSize = await _selectedImage!.length();
    if (fileSize > OperaStudioConfig.maxFileSizeBytes) {
      throw Exception('Image too large. Maximum size is ${OperaStudioConfig.maxFileSizeBytes ~/ (1024 * 1024)}MB');
    }

    // Check credits - for development, we'll use local credits
    if (_userCredits < 1) {
      throw InsufficientCreditsException('You need 1 credit to enhance this image. You have $_userCredits credits remaining.');
    }
  }

  Future<Map<String, dynamic>> _pollForResultWithProgress(String predictionId) async {
    for (int attempt = 0; attempt < 120; attempt++) {
      final result = await WebAPIService.checkStatus(predictionId);
      
      if (result['status'] == 'succeeded') {
        return result;
      } else if (result['status'] == 'failed') {
        throw ProcessingException('AI processing failed: ${result['error']}');
      }
      
      // Update progress based on status
      if (result['status'] == 'processing') {
        _processingProgress = 0.3 + (attempt / 120.0) * 0.4; // 30% to 70%
        notifyListeners();
      }
      
      await Future.delayed(const Duration(seconds: 1));
    }
    
    throw TimeoutException('Processing took too long. Please try again.');
  }

  Future<void> _processEnhancedResult(Map<String, dynamic> result) async {
    if (result['output'] == null) {
      throw ProcessingException('No enhanced image received');
    }
    
    // ✅ FIXED: Handle the correct data structure from API
    final imageUrl = result['output']['denoised_image'];
    if (imageUrl == null) {
      throw ProcessingException('No enhanced image URL found');
    }
    final enhancedBytes = await WebAPIService.downloadImage(imageUrl);
    
    // Save to temporary file
    final tempDir = await getTemporaryDirectory();
    final tempFile = File('${tempDir.path}/enhanced_${DateTime.now().millisecondsSinceEpoch}.png');
    await tempFile.writeAsBytes(enhancedBytes);
    
    _processedImage = tempFile;
    // ✅ ENHANCED: Replace the original image with the enhanced version
    _selectedImage = tempFile;
  }

  Future<void> _updateUserCreditsAndHistory() async {
    // For development, just deduct 1 credit locally
    _userCredits -= 1;
    
    // In production, you would refresh from server:
    // final creditInfo = await CreditService.getUserCredits();
    // _userCredits = creditInfo['credits_remaining'];
    
    // Add to processing history
    await ProcessingHistoryService.addProcessingRecord(
      processingType: 'general_enhancement',
      creditsConsumed: 1,
      status: 'completed',
      resultUrl: _processedImage?.path,
    );
  }

  String _handleProcessingError(dynamic error) {
    if (error is InsufficientCreditsException) {
      return error.message;
    } else if (error is ProcessingException) {
      return error.message;
    } else if (error is TimeoutException) {
      return 'Processing timed out. Please check your connection and try again.';
    } else if (error.toString().contains('401')) {
      return 'Session expired. Please sign in again.';
    } else if (error.toString().contains('429')) {
      return 'Too many requests. Please wait a moment and try again.';
    } else {
      return 'Enhancement failed. Please try again.';
    }
  }

  // Save functionality
  bool _isSaving = false;
  bool get isSaving => _isSaving;
  bool get hasEnhancedImage => _processedImage != null;

  Future<void> saveImageToGallery() async {
    if (_processedImage == null) {
      setError('No enhanced image to save');
      return;
    }

    _isSaving = true;
    notifyListeners();

    try {
      // Get current user
      final user = AuthService.getCurrentUser();
      if (user == null) {
        throw Exception('User not authenticated');
      }

      // Upload to cloud storage
      final uploadResult = await CloudStorageService.uploadImage(
        _processedImage!,
        user.id,
        customFileName: 'enhanced_image_${DateTime.now().millisecondsSinceEpoch}.png',
      );

      if (!uploadResult['success']) {
        throw Exception('Failed to upload to cloud storage: ${uploadResult['error']}');
      }

      // Save metadata to database
      final metadataSaved = await CloudStorageService.saveImageMetadata(
        userId: user.id,
        originalFilename: uploadResult['fileName'],
        storagePath: uploadResult['storagePath'],
        fileSize: uploadResult['fileSize'],
        mimeType: 'image/png',
        processingType: 'general_enhancement',
        creditsConsumed: 1,
      );

      if (!metadataSaved) {
        print('⚠️ Warning: Image uploaded but metadata not saved');
      }

      // Also save locally as backup
      final directory = await getDownloadsDirectory();
      if (directory != null) {
        final timestamp = DateTime.now().millisecondsSinceEpoch;
        final fileName = 'enhanced_image_$timestamp.png';
        final localFile = File('${directory.path}/$fileName');
        await _processedImage!.copy(localFile.path);
        print('✅ Image also saved locally: ${localFile.path}');
      }

      print('✅ Image saved to cloud storage: ${uploadResult['publicUrl']}');
      clearError(); // Clear any previous error
      
    } catch (e) {
      print('❌ Error saving image: $e');
      setError('Failed to save image. Error: $e');
    } finally {
      _isSaving = false;
      notifyListeners();
    }
  }
}
